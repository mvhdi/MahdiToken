pragma solidity ^0.4.2;

// imports the token that is going to be sold
import "./MahdiToken.sol";

//declare contract
contract MahdiTokenSale {
	// state var to keep track of admin account
	address admin; 

	//state var of contract data type
	MahdiToken public tokenContract;

	// state var is public and is generated by solidity
	uint256 public tokenPrice;

	uint256 public tokensSold;

	event Sell(address _buyer, uint256 _amount);

	//constructor
	function MahdiTokenSale(MahdiToken _tokenContract, uint256 _tokenPrice) public {
		// assign the admin account to the person deploying the contract
		admin = msg.sender;
		// assign Token contract, so we can purchase tokens from admin
		tokenContract = _tokenContract;
		// set the token price 
		tokenPrice = _tokenPrice;	
	}

	// function for safe mutlplication in solidity
	function multiply(uint x, uint y) internal pure returns (uint z) {
		require( y ==0 || (z = x*y) /y == x); 
	}



	// function to buy tokens
	function buyTokens(uint256 _numberOfTokens) public payable {
		// require the value to be = tokens
		require(msg.value == multiply(_numberOfTokens,tokenPrice));
		// require that the contract has enough tokens

		// this refers to the smart contract address
		require(tokenContract.balanceOf(this) >= _numberOfTokens);
		// require that a transfer is successful
		require(tokenContract.transfer(msg.sender, _numberOfTokens));
		// keep track of the # of tokens sold
		tokensSold += _numberOfTokens;

		// trigger sell event
		Sell(msg.sender, _numberOfTokens);

	}

	// function ends the MahdiTokenSale

	function endSale() public {
		// require only admin can use this function
		require(msg.sender == admin);
		//return unsold tokens to the admin account
		require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));
		// deactivate this contract (called sefl-destruct aka suicide in Solidity)
		// instead transfer the balance to the admin, issues with solidity's self destruct method
		admin.transfer(address(this).balance);
		// selfdestruct(admin);

	}

}
